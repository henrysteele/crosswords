import {
  __commonJS,
  __require
} from "./chunk-TDUMLE5V.js";

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/typo-js/typo.js
var require_typo = __commonJS({
  "node_modules/typo-js/typo.js"(exports, module) {
    var Typo;
    (function() {
      "use strict";
      Typo = function(dictionary, affData, wordsData, settings) {
        settings = settings || {};
        this.dictionary = null;
        this.rules = {};
        this.dictionaryTable = {};
        this.compoundRules = [];
        this.compoundRuleCodes = {};
        this.replacementTable = [];
        this.flags = settings.flags || {};
        this.memoized = {};
        this.loaded = false;
        var self = this;
        var path;
        var i, j, _len, _jlen;
        if (dictionary) {
          self.dictionary = dictionary;
          if (affData && wordsData) {
            setup();
          } else if (typeof window !== "undefined" && "chrome" in window && "extension" in window.chrome && "getURL" in window.chrome.extension) {
            if (settings.dictionaryPath) {
              path = settings.dictionaryPath;
            } else {
              path = "typo/dictionaries";
            }
            if (!affData)
              readDataFile(chrome.extension.getURL(path + "/" + dictionary + "/" + dictionary + ".aff"), setAffData);
            if (!wordsData)
              readDataFile(chrome.extension.getURL(path + "/" + dictionary + "/" + dictionary + ".dic"), setWordsData);
          } else {
            if (settings.dictionaryPath) {
              path = settings.dictionaryPath;
            } else if (typeof __dirname !== "undefined") {
              path = __dirname + "/dictionaries";
            } else {
              path = "./dictionaries";
            }
            if (!affData)
              readDataFile(path + "/" + dictionary + "/" + dictionary + ".aff", setAffData);
            if (!wordsData)
              readDataFile(path + "/" + dictionary + "/" + dictionary + ".dic", setWordsData);
          }
        }
        function readDataFile(url, setFunc) {
          var response = self._readFile(url, null, settings.asyncLoad);
          if (settings.asyncLoad) {
            response.then(function(data) {
              setFunc(data);
            });
          } else {
            setFunc(response);
          }
        }
        function setAffData(data) {
          affData = data;
          if (wordsData) {
            setup();
          }
        }
        function setWordsData(data) {
          wordsData = data;
          if (affData) {
            setup();
          }
        }
        function setup() {
          self.rules = self._parseAFF(affData);
          self.compoundRuleCodes = {};
          for (i = 0, _len = self.compoundRules.length; i < _len; i++) {
            var rule = self.compoundRules[i];
            for (j = 0, _jlen = rule.length; j < _jlen; j++) {
              self.compoundRuleCodes[rule[j]] = [];
            }
          }
          if ("ONLYINCOMPOUND" in self.flags) {
            self.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];
          }
          self.dictionaryTable = self._parseDIC(wordsData);
          for (i in self.compoundRuleCodes) {
            if (self.compoundRuleCodes[i].length === 0) {
              delete self.compoundRuleCodes[i];
            }
          }
          for (i = 0, _len = self.compoundRules.length; i < _len; i++) {
            var ruleText = self.compoundRules[i];
            var expressionText = "";
            for (j = 0, _jlen = ruleText.length; j < _jlen; j++) {
              var character = ruleText[j];
              if (character in self.compoundRuleCodes) {
                expressionText += "(" + self.compoundRuleCodes[character].join("|") + ")";
              } else {
                expressionText += character;
              }
            }
            self.compoundRules[i] = new RegExp(expressionText, "i");
          }
          self.loaded = true;
          if (settings.asyncLoad && settings.loadedCallback) {
            settings.loadedCallback(self);
          }
        }
        return this;
      };
      Typo.prototype = {
        /**
         * Loads a Typo instance from a hash of all of the Typo properties.
         *
         * @param object obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).
         */
        load: function(obj) {
          for (var i in obj) {
            if (obj.hasOwnProperty(i)) {
              this[i] = obj[i];
            }
          }
          return this;
        },
        /**
         * Read the contents of a file.
         * 
         * @param {String} path The path (relative) to the file.
         * @param {String} [charset="ISO8859-1"] The expected charset of the file
         * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all
         *        files are read synchronously.
         * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is
         *          always returned.
         */
        _readFile: function(path, charset, async) {
          charset = charset || "utf8";
          if (typeof XMLHttpRequest !== "undefined") {
            var promise;
            var req = new XMLHttpRequest();
            req.open("GET", path, async);
            if (async) {
              promise = new Promise(function(resolve, reject) {
                req.onload = function() {
                  if (req.status === 200) {
                    resolve(req.responseText);
                  } else {
                    reject(req.statusText);
                  }
                };
                req.onerror = function() {
                  reject(req.statusText);
                };
              });
            }
            if (req.overrideMimeType)
              req.overrideMimeType("text/plain; charset=" + charset);
            req.send(null);
            return async ? promise : req.responseText;
          } else if (typeof __require !== "undefined") {
            var fs = require_fs();
            try {
              if (fs.existsSync(path)) {
                return fs.readFileSync(path, charset);
              } else {
                console.log("Path " + path + " does not exist.");
              }
            } catch (e) {
              console.log(e);
              return "";
            }
          }
        },
        /**
         * Parse the rules out from a .aff file.
         *
         * @param {String} data The contents of the affix file.
         * @returns object The rules from the file.
         */
        _parseAFF: function(data) {
          var rules = {};
          var line, subline, numEntries, lineParts;
          var i, j, _len, _jlen;
          var lines = data.split(/\r?\n/);
          for (i = 0, _len = lines.length; i < _len; i++) {
            line = this._removeAffixComments(lines[i]);
            line = line.trim();
            if (!line) {
              continue;
            }
            var definitionParts = line.split(/\s+/);
            var ruleType = definitionParts[0];
            if (ruleType == "PFX" || ruleType == "SFX") {
              var ruleCode = definitionParts[1];
              var combineable = definitionParts[2];
              numEntries = parseInt(definitionParts[3], 10);
              var entries = [];
              for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
                subline = lines[j];
                lineParts = subline.split(/\s+/);
                var charactersToRemove = lineParts[2];
                var additionParts = lineParts[3].split("/");
                var charactersToAdd = additionParts[0];
                if (charactersToAdd === "0")
                  charactersToAdd = "";
                var continuationClasses = this.parseRuleCodes(additionParts[1]);
                var regexToMatch = lineParts[4];
                var entry = {};
                entry.add = charactersToAdd;
                if (continuationClasses.length > 0)
                  entry.continuationClasses = continuationClasses;
                if (regexToMatch !== ".") {
                  if (ruleType === "SFX") {
                    entry.match = new RegExp(regexToMatch + "$");
                  } else {
                    entry.match = new RegExp("^" + regexToMatch);
                  }
                }
                if (charactersToRemove != "0") {
                  if (ruleType === "SFX") {
                    entry.remove = new RegExp(charactersToRemove + "$");
                  } else {
                    entry.remove = charactersToRemove;
                  }
                }
                entries.push(entry);
              }
              rules[ruleCode] = { "type": ruleType, "combineable": combineable == "Y", "entries": entries };
              i += numEntries;
            } else if (ruleType === "COMPOUNDRULE") {
              numEntries = parseInt(definitionParts[1], 10);
              for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
                line = lines[j];
                lineParts = line.split(/\s+/);
                this.compoundRules.push(lineParts[1]);
              }
              i += numEntries;
            } else if (ruleType === "REP") {
              lineParts = line.split(/\s+/);
              if (lineParts.length === 3) {
                this.replacementTable.push([lineParts[1], lineParts[2]]);
              }
            } else {
              this.flags[ruleType] = definitionParts[1];
            }
          }
          return rules;
        },
        /**
         * Removes comments.
         *
         * @param {String} data A line from an affix file.
         * @return {String} The cleaned-up line.
         */
        _removeAffixComments: function(line) {
          if (line.match(/^\s*#/, "")) {
            return "";
          }
          return line;
        },
        /**
         * Parses the words out from the .dic file.
         *
         * @param {String} data The data from the dictionary file.
         * @returns object The lookup table containing all of the words and
         *                 word forms from the dictionary.
         */
        _parseDIC: function(data) {
          data = this._removeDicComments(data);
          var lines = data.split(/\r?\n/);
          var dictionaryTable = {};
          function addWord(word2, rules) {
            if (!dictionaryTable.hasOwnProperty(word2)) {
              dictionaryTable[word2] = null;
            }
            if (rules.length > 0) {
              if (dictionaryTable[word2] === null) {
                dictionaryTable[word2] = [];
              }
              dictionaryTable[word2].push(rules);
            }
          }
          for (var i = 1, _len = lines.length; i < _len; i++) {
            var line = lines[i];
            if (!line) {
              continue;
            }
            var parts = line.split("/", 2);
            var word = parts[0];
            if (parts.length > 1) {
              var ruleCodesArray = this.parseRuleCodes(parts[1]);
              if (!("NEEDAFFIX" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {
                addWord(word, ruleCodesArray);
              }
              for (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {
                var code = ruleCodesArray[j];
                var rule = this.rules[code];
                if (rule) {
                  var newWords = this._applyRule(word, rule);
                  for (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {
                    var newWord = newWords[ii];
                    addWord(newWord, []);
                    if (rule.combineable) {
                      for (var k = j + 1; k < _jlen; k++) {
                        var combineCode = ruleCodesArray[k];
                        var combineRule = this.rules[combineCode];
                        if (combineRule) {
                          if (combineRule.combineable && rule.type != combineRule.type) {
                            var otherNewWords = this._applyRule(newWord, combineRule);
                            for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {
                              var otherNewWord = otherNewWords[iii];
                              addWord(otherNewWord, []);
                            }
                          }
                        }
                      }
                    }
                  }
                }
                if (code in this.compoundRuleCodes) {
                  this.compoundRuleCodes[code].push(word);
                }
              }
            } else {
              addWord(word.trim(), []);
            }
          }
          return dictionaryTable;
        },
        /**
         * Removes comment lines and then cleans up blank lines and trailing whitespace.
         *
         * @param {String} data The data from a .dic file.
         * @return {String} The cleaned-up data.
         */
        _removeDicComments: function(data) {
          data = data.replace(/^\t.*$/mg, "");
          return data;
        },
        parseRuleCodes: function(textCodes) {
          if (!textCodes) {
            return [];
          } else if (!("FLAG" in this.flags)) {
            return textCodes.split("");
          } else if (this.flags.FLAG === "long") {
            var flags = [];
            for (var i = 0, _len = textCodes.length; i < _len; i += 2) {
              flags.push(textCodes.substr(i, 2));
            }
            return flags;
          } else if (this.flags.FLAG === "num") {
            return textCodes.split(",");
          } else if (this.flags.FLAG === "UTF-8") {
            return Array.from(textCodes);
          } else {
            return textCodes.split("");
          }
        },
        /**
         * Applies an affix rule to a word.
         *
         * @param {String} word The base word.
         * @param {Object} rule The affix rule.
         * @returns {String[]} The new words generated by the rule.
         */
        _applyRule: function(word, rule) {
          var entries = rule.entries;
          var newWords = [];
          for (var i = 0, _len = entries.length; i < _len; i++) {
            var entry = entries[i];
            if (!entry.match || word.match(entry.match)) {
              var newWord = word;
              if (entry.remove) {
                newWord = newWord.replace(entry.remove, "");
              }
              if (rule.type === "SFX") {
                newWord = newWord + entry.add;
              } else {
                newWord = entry.add + newWord;
              }
              newWords.push(newWord);
              if ("continuationClasses" in entry) {
                for (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {
                  var continuationRule = this.rules[entry.continuationClasses[j]];
                  if (continuationRule) {
                    newWords = newWords.concat(this._applyRule(newWord, continuationRule));
                  }
                }
              }
            }
          }
          return newWords;
        },
        /**
         * Checks whether a word or a capitalization variant exists in the current dictionary.
         * The word is trimmed and several variations of capitalizations are checked.
         * If you want to check a word without any changes made to it, call checkExact()
         *
         * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function
         *
         * @param {String} aWord The word to check.
         * @returns {Boolean}
         */
        check: function(aWord) {
          if (!this.loaded) {
            throw "Dictionary not loaded.";
          }
          if (!aWord) {
            return false;
          }
          var trimmedWord = aWord.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
          if (this.checkExact(trimmedWord)) {
            return true;
          }
          if (trimmedWord.toUpperCase() === trimmedWord) {
            var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();
            if (this.hasFlag(capitalizedWord, "KEEPCASE")) {
              return false;
            }
            if (this.checkExact(capitalizedWord)) {
              return true;
            }
            if (this.checkExact(trimmedWord.toLowerCase())) {
              return true;
            }
          }
          var uncapitalizedWord = trimmedWord[0].toLowerCase() + trimmedWord.substring(1);
          if (uncapitalizedWord !== trimmedWord) {
            if (this.hasFlag(uncapitalizedWord, "KEEPCASE")) {
              return false;
            }
            if (this.checkExact(uncapitalizedWord)) {
              return true;
            }
          }
          return false;
        },
        /**
         * Checks whether a word exists in the current dictionary.
         *
         * @param {String} word The word to check.
         * @returns {Boolean}
         */
        checkExact: function(word) {
          if (!this.loaded) {
            throw "Dictionary not loaded.";
          }
          var ruleCodes = this.dictionaryTable[word];
          var i, _len;
          if (typeof ruleCodes === "undefined") {
            if ("COMPOUNDMIN" in this.flags && word.length >= this.flags.COMPOUNDMIN) {
              for (i = 0, _len = this.compoundRules.length; i < _len; i++) {
                if (word.match(this.compoundRules[i])) {
                  return true;
                }
              }
            }
          } else if (ruleCodes === null) {
            return true;
          } else if (typeof ruleCodes === "object") {
            for (i = 0, _len = ruleCodes.length; i < _len; i++) {
              if (!this.hasFlag(word, "ONLYINCOMPOUND", ruleCodes[i])) {
                return true;
              }
            }
          }
          return false;
        },
        /**
         * Looks up whether a given word is flagged with a given flag.
         *
         * @param {String} word The word in question.
         * @param {String} flag The flag in question.
         * @return {Boolean}
         */
        hasFlag: function(word, flag, wordFlags) {
          if (!this.loaded) {
            throw "Dictionary not loaded.";
          }
          if (flag in this.flags) {
            if (typeof wordFlags === "undefined") {
              wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);
            }
            if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {
              return true;
            }
          }
          return false;
        },
        /**
         * Returns a list of suggestions for a misspelled word.
         *
         * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.
         * This suggestor is primitive, but it works.
         *
         * @param {String} word The misspelling.
         * @param {Number} [limit=5] The maximum number of suggestions to return.
         * @returns {String[]} The array of suggestions.
         */
        alphabet: "",
        suggest: function(word, limit) {
          if (!this.loaded) {
            throw "Dictionary not loaded.";
          }
          limit = limit || 5;
          if (this.memoized.hasOwnProperty(word)) {
            var memoizedLimit = this.memoized[word]["limit"];
            if (limit <= memoizedLimit || this.memoized[word]["suggestions"].length < memoizedLimit) {
              return this.memoized[word]["suggestions"].slice(0, limit);
            }
          }
          if (this.check(word))
            return [];
          for (var i = 0, _len = this.replacementTable.length; i < _len; i++) {
            var replacementEntry = this.replacementTable[i];
            if (word.indexOf(replacementEntry[0]) !== -1) {
              var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);
              if (this.check(correctedWord)) {
                return [correctedWord];
              }
            }
          }
          if (!this.alphabet) {
            this.alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            if ("TRY" in this.flags) {
              this.alphabet += this.flags["TRY"];
            }
            if ("WORDCHARS" in this.flags) {
              this.alphabet += this.flags["WORDCHARS"];
            }
            var alphaArray = this.alphabet.split("");
            alphaArray.sort();
            var alphaHash = {};
            for (var i = 0; i < alphaArray.length; i++) {
              alphaHash[alphaArray[i]] = true;
            }
            this.alphabet = "";
            for (var i in alphaHash) {
              this.alphabet += i;
            }
          }
          var self = this;
          function edits1(words, known_only) {
            var rv = {};
            var i2, j, _iilen, _len2, _jlen, _edit;
            var alphabetLength = self.alphabet.length;
            if (typeof words == "string") {
              var word2 = words;
              words = {};
              words[word2] = true;
            }
            for (var word2 in words) {
              for (i2 = 0, _len2 = word2.length + 1; i2 < _len2; i2++) {
                var s = [word2.substring(0, i2), word2.substring(i2)];
                if (s[1]) {
                  _edit = s[0] + s[1].substring(1);
                  if (!known_only || self.check(_edit)) {
                    if (!(_edit in rv)) {
                      rv[_edit] = 1;
                    } else {
                      rv[_edit] += 1;
                    }
                  }
                }
                if (s[1].length > 1 && s[1][1] !== s[1][0]) {
                  _edit = s[0] + s[1][1] + s[1][0] + s[1].substring(2);
                  if (!known_only || self.check(_edit)) {
                    if (!(_edit in rv)) {
                      rv[_edit] = 1;
                    } else {
                      rv[_edit] += 1;
                    }
                  }
                }
                if (s[1]) {
                  var lettercase = s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1) ? "uppercase" : "lowercase";
                  for (j = 0; j < alphabetLength; j++) {
                    var replacementLetter = self.alphabet[j];
                    if ("uppercase" === lettercase) {
                      replacementLetter = replacementLetter.toUpperCase();
                    }
                    if (replacementLetter != s[1].substring(0, 1)) {
                      _edit = s[0] + replacementLetter + s[1].substring(1);
                      if (!known_only || self.check(_edit)) {
                        if (!(_edit in rv)) {
                          rv[_edit] = 1;
                        } else {
                          rv[_edit] += 1;
                        }
                      }
                    }
                  }
                }
                if (s[1]) {
                  for (j = 0; j < alphabetLength; j++) {
                    var lettercase = s[0].substring(-1).toUpperCase() === s[0].substring(-1) && s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1) ? "uppercase" : "lowercase";
                    var replacementLetter = self.alphabet[j];
                    if ("uppercase" === lettercase) {
                      replacementLetter = replacementLetter.toUpperCase();
                    }
                    _edit = s[0] + replacementLetter + s[1];
                    if (!known_only || self.check(_edit)) {
                      if (!(_edit in rv)) {
                        rv[_edit] = 1;
                      } else {
                        rv[_edit] += 1;
                      }
                    }
                  }
                }
              }
            }
            return rv;
          }
          function correct(word2) {
            var ed1 = edits1(word2);
            var ed2 = edits1(ed1, true);
            var weighted_corrections = ed2;
            for (var ed1word in ed1) {
              if (!self.check(ed1word)) {
                continue;
              }
              if (ed1word in weighted_corrections) {
                weighted_corrections[ed1word] += ed1[ed1word];
              } else {
                weighted_corrections[ed1word] = ed1[ed1word];
              }
            }
            var i2, _len2;
            var sorted_corrections = [];
            for (i2 in weighted_corrections) {
              if (weighted_corrections.hasOwnProperty(i2)) {
                sorted_corrections.push([i2, weighted_corrections[i2]]);
              }
            }
            function sorter(a, b) {
              var a_val = a[1];
              var b_val = b[1];
              if (a_val < b_val) {
                return -1;
              } else if (a_val > b_val) {
                return 1;
              }
              return b[0].localeCompare(a[0]);
            }
            sorted_corrections.sort(sorter).reverse();
            var rv = [];
            var capitalization_scheme = "lowercase";
            if (word2.toUpperCase() === word2) {
              capitalization_scheme = "uppercase";
            } else if (word2.substr(0, 1).toUpperCase() + word2.substr(1).toLowerCase() === word2) {
              capitalization_scheme = "capitalized";
            }
            var working_limit = limit;
            for (i2 = 0; i2 < Math.min(working_limit, sorted_corrections.length); i2++) {
              if ("uppercase" === capitalization_scheme) {
                sorted_corrections[i2][0] = sorted_corrections[i2][0].toUpperCase();
              } else if ("capitalized" === capitalization_scheme) {
                sorted_corrections[i2][0] = sorted_corrections[i2][0].substr(0, 1).toUpperCase() + sorted_corrections[i2][0].substr(1);
              }
              if (!self.hasFlag(sorted_corrections[i2][0], "NOSUGGEST") && rv.indexOf(sorted_corrections[i2][0]) == -1) {
                rv.push(sorted_corrections[i2][0]);
              } else {
                working_limit++;
              }
            }
            return rv;
          }
          this.memoized[word] = {
            "suggestions": correct(word),
            "limit": limit
          };
          return this.memoized[word]["suggestions"];
        }
      };
    })();
    if (typeof module !== "undefined") {
      module.exports = Typo;
    }
  }
});
export default require_typo();
//# sourceMappingURL=typo-js.js.map
